# Cálculo numérico para engenharia elétrica com PYTHON
# Capítulo 4: Raízes_PROPOSTO1
# Método intervalar: Bissecçãoo
# Catenaria

import numpy as np
import math as m
import matplotlib.pyplot as plt

#catenaria
#hx = x*(cosh(d/(2*x))-1)-f
d = 500
f = 50

iter = 1        # número de iterações
x1 = 500        # aproximação inferior
xu = 700        # aproximação superior
es = 0.0001     # erro relativo desejado
maxit = 50      # número máximo de iterações

# raiz = raiz real
# fx = valor da função em raiz
# ea = erro relativo aproximado
b=[]
fb=[]
xr = x1
ea = 100
while True:
    xr_velho = xr
    xr = (x1+xu)/2
    b.append(xr)   #para gráfico
    if xr != 0:
      ea = abs((xr-xr_velho)/xr)*100
    #função em estudo
    fx1 = np.dot(x1,(m.cosh(d/(2*x1))-1))-f 
    fxr = np.dot(xr,(m.cosh(d/(2*xr))-1))-f 
    fb.append(fxr) #para gráfico
    test = fx1*fxr
    if test < 0:
        xu=xr
    elif test > 0:
        x1=xr
    else:
        ea=0

    iter += 1
    if ea <= es or iter >= maxit:
        break

print(f'raiz = {xr:.2f}')
fxr = np.multiply(xr,(m.cosh(d/(2*xr))-1))-f
print(f'ea = {ea}')
print(f'iter = {iter}')

#grafico
xmin=500
xmax=700
ns=100
x = np.linspace(xmin, xmax, ns)   # cria um vetor de valores para x
fx = np.multiply(x,(np.cosh(d/(2*x))-1))-f      # função em estudo
plt.grid(True)
plt.plot(x,fx)      #plota a função em estudo
plt.plot(b, fb, 'o', markeredgecolor='r',color='none')
plt.plot(raiz,fxr,'ks',linewidth=2,markersize=5)
plt.tight_layout(True)
plt.show()
